#C++语法细节

####变量类型
######理解变量类型

* 类型修饰符(*或&)仅仅修饰单个变量
* 从右向左阅读r的定义。离变量名最近的符号对变量的类型有最直接的影响。
```cpp
int *p， q;   //p是int型指针，q是int
int *&r = p;  //r是对指针p的引用
int (*a)[n];  //数组指针：指向int数组的指针
int   *a[n]； //指针数组：[ ]的优先级高，a是一个数组，存放int*类型元素。
```

######声明、定义、初始化
* 变量能且只能被定义一次，但是可以被声明多次。
```cpp
extern int i;			//声明i
int j;       			//声明并定义j
extern double pi=3.1416;//定义并初始化,此时虽然有extern语句，但是因为加了
```

######数组的特殊性
* 数组不允许拷贝和赋值
* 在很多用到数组名字的地方，编译器会自动把其替换成一个指向数组第一个元素的指针。使用auto时是这样，**decltype时这种转变不会发生**。
```cpp
int a[] = {0,1,2};
int a2[] = a;    //错误：不允许使用一个数组初始化另一个数组
a2 = a;          //错误：不允许把一个数组直接赋值给另一个数组
auto ia(a);      //ia是一个整型指针，指向a的第一个元素
decltype(a) ia3={1,2.3}； //decltype(a)返回的类型是由3个元素构成的数组
```

######类型转换
* 无符号类型注意不能赋值成负数。否则值实际为对这个负数取模。
* 赋值给带符号类型一个超出它表示范围的值时，结果是未定义的。
* 显式类型转换（cast）
	* static_cast:处理具有明确定义的类型转换，不包含底层const。，这种强制转换只会在编译时检查。 如果编译器检测到您尝试强制转换完全不兼容的类型，则static_cast会返回错误。
	* reinterpret:处理非关联的类型转换，通过改变对象的位模式。例如 pointer 和 int的无关类型的转换。
	* const_cast:只能改变运算对象的底层const,
	* dynamic_cast：在运行时检查基类指针和派生类指针之间的强制转换。


___
####作用域
######作用域嵌套
* 内层作用域可以重定义外层作用域已有的名字。
* 但可以通过作用域操作符来访问外层变量。::是**作用域操作符**。全局作用域没有名字，所以::name是特指全局作用域里的name变量。


___
####const限定符

######const基本对象
* const对象一旦创建后其值就不能改变，所以const对象必须初始化
* 默认情况下const对象仅在文件内有效，不同文件需要定义同名的const变量，它们是独立的。
* 如果想只在一个文件内定义，可以使用extern关键字。**定义语句前加extern关键字**。
```cpp
//文件1中定义，该常量能被其他文件访问
extern cnost int bufSize = fcn();
//文件2中的声明，与文件1中是同一个
extern const int bufSize;
```

######const与引用
* 对const的引用，简称常量引用，即把引用绑定到const对象上。**底层const**。
* 想要引用常量必须使用常量引用，但常量引用可以引用非常量对象。
* 允许为一个常量引用绑定非常量的对象、字面值，甚至一般表达式。而非常量引用是不可以的。

######const与指针
* 指向常量的指针：想要存放常量对象的地址，只能使用指向常量的指针。**底层const**。
* const指针：指针本身是const，即指针初始化后的值（那个地址）不能改变。**顶层const**。
```cpp
const int a;
const int &b =a;     //常量引用，底层const
const int *p1 = &a;  //指向常量的指针，底层const
int *const p2 = &a;  //常量指针，p2永远指向a,顶层const
```
**在拷贝操作时，拷入和拷出的变量必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。
一般来说，非常量可以转换成常量，反之则不行**


___
####异常处理

######try语句块

* throw表达式，可以用来引发异常。
* try语句块处理异常，以try关键字开始，并以多个catch子句结束。
* 异常类，用于在throw表达式和相关的catch子句之间传递异常的具体信息。


___
####函数

######尾置返回类型
* 以auto开头，以->返回类型结尾。
```cpp
int (*func(int i))[10];         //直接写法
auto func(int i) -> int(*)[10]; //尾置返回类型。返回一个指针，该指针指向含有10个整数的数组
typedef int arrT[10];			//arrT是一个类型别名
using arrT= int[10];			//arrT的等价声明
arrT* func(int i);              //使用类型别名。返回类型同上
```
######局部静态对象
* 局部静态对象在程序执行路径第一次经过对象定义语句时初始化，直到程序终止才被销毁。在此期间即使对象所在的函数结束执行，也不会对它造成影响。**它的值可以改变。**

######含有可变形参的函数
* initializer_list形参：这是在标准库中定义的一个模板类，其中的对象永远是const值无法改变。而且拷贝或赋值一个initializer_list对象使用的是**传引用**赋值。
* 省略符形参：为了便于C++程序访问某些特殊的C代码而设置的，通常不用于其他目的。
```cpp
    void error_msg(initializer_list<string> il);
    error_msg({"a","b"});
    error_msg({"a","b","c"});
    void foo(parm_list, ...); //逗号是可选的
```

######a

