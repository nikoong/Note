#并发编程

构造并发程序的方法：
进程：
- 内核自动管理
- 每个进程有其私有的地址空间


I/O多路复用
- 由程序员手动控制多个逻辑流
- 所有的逻辑流共享同一个地址空间


线程：看成上两种方式的混合体
- 内核自动管理多个逻辑流
- 每个线程共享地址空间
- 线程栈和内核栈



>Unix 进程间通信（IPC，Inter-Process Communication）指允许进程和其他进程进行通信的技术。
- 信号
- 套接字接口
- 管道
- 消息队列 先进先出（FIFO）
- 系统V共享内存
- 系统V信号量
- 辅助命令 ipcs命令用于报告共享内存、信号量和消息队列信息。


[I/O多路复用技术（multiplexing）是什么？](https://www.zhihu.com/question/28594409/answer/74003996)
	
>I/O多路复用，又称为事件驱动，是现代高性能服务器采用的编程方式。
　　通常IO操作都是阻塞I/O的，也就是说当你调用read时，如果没有数据收到，那么线程或者进程就会被挂起，直到收到数	据。这样，当服务器需要处理1000个连接的的时候，而且只有很少连接忙碌的，那么会需要1000个线程或进程来处理1000个连接，而1000个线程大部分是被阻塞起来。CPU需要管理1000个线程或进程，开销很大。
　　这时就要引入非阻塞I/O。通过fcntl（POSIX）或ioctl（Unix）设为非阻塞模式，这时，当你调用read时，如果有数据收到，就返回数据，如果没有数据收到，就立刻返回一个错误，如EWOULDBLOCK。这样是不会阻塞线程了，但是你还是要不断的轮询来读取或写入。
　　于是，我们需要引入IO多路复用的概念。**多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态**，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。这样在处理1000个连接时，只需要1个线程监控就绪状态，对就绪的每个连接开一个线程处理就可以了，这样需要的线程数大大减少，减少了内存开销和上下文切换的CPU开销。


线程
每个线程有自己的上下文
共享进程虚拟地址空间的所有内容。

对等线程，线程池

分离线程


#### 多线程模型

　　要理解得从两个方面：内存模型和C程序

#####1.内存模型

　　先回顾一下进程的虚拟内存，Linux为每一个进程都维护了一个单独的虚拟内存。虚拟内存首先分为内核虚拟内存和进程虚拟内存。我们主要看进程虚拟内存。它分为代码段、数据段（C语言中存放静态变量，全局变量，字符串常量）、堆、共享库段以及用户栈。我们知道用户栈存放局部变量，堆存放由malloc分配的空间的数据。
　　每个线程都与进程共享同一个虚拟内存空间。但是每个线程都会在**进程的堆**开辟自己的用户栈。这意味着：

1. 每个线程有自己的上下文：线程ID，栈，栈指针，程序计数器，条件码，和通用目的寄存器。这都是线程运行时会使用到的。当线程切换时，线程上下文就保存在线程的栈上。

2. 每个线程和其他线程共享整个虚拟地址空间：代码段，数据段、堆以及共享库段，但没有用户栈。

3. **注意**：存在寄存器的值是隔离且被保护的，在实际操作上，其他线程永远没法访问到。但是在栈中的值并不是这样的。虽然线程的栈是各自独立的，但是各个线程都共享整个进程的虚拟内存空间，而栈是开辟在虚拟空间内部的。所以如果能得到一个线程栈上变量的地址，那其他线程也能通过这个地址访问到该变量。


###优劣总结

- 基于进程
    - 难以共享资源，但同时也避免了可能带来的共享问题
    - 添加/移除进程开销较大
- 基于事件
    - 非常底层的实现机制
    - 使用全局控制而非调度
    - 开销比较小
    - 但是无法提供精细度较高的并行
    - 无法充分利用多核处理器
- 基于线程
    - 容易共享资源，但也容易出现问题
    - 开销比进程小
    - 对于具体的调度可控性较低
    - 难以调试（因为事件发生的顺序不一致）


多线程的同步
信号量：
当缓冲区只有一个的时候不需要互斥锁

见的错误有仨：竞争条件[2]、死锁[3]和活锁[4]

